<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

<head>
<title><a href=./default.aspx>Claudio Russo</a>'s Publications</title>
</head>

<body>

<!-- This document was automatically generated with bibtex2html 1.74
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     ..\bib\bibtex2html-1.74.exe -output publications -title "<a href=./default.aspx>Claudio Russo</a>'s Publications" -both -r -d -nobibsource ..\bib\crusso.bib  -->

<h1><a href=./default.aspx>Claudio Russo</a>'s Publications</h1>
<table>

<tr valign="top">
<td align="right">
[<a name="popl16fabular">1</a>]
</td>
<td>
Johannes Borgstrˆm, Andrew&nbsp;D. Gordon, Long Ouyang, Claudio Russo, Adam
  Scibior, and Marcin Szymczak.
  Fabular: Regression formulas as probabilistic programming.
  In <em>Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium
  on Principles of Programming Languages</em>, POPL '16, pages 271-283, New York,
  NY, USA, 2016. ACM.<br />
[ <a href="http://doi.acm.org/10.1145/2837614.2837653">http</a> ]
<blockquote><font size="-1">

Regression formulas are a domain-specific language adopted by several R packages for describing an important and useful class of statistical models: hierarchical linear regressions. Formulas are succinct, expressive, and clearly popular, so are they a useful addition to probabilistic programming languages? And what do they mean? We propose a core calculus of hierarchical linear regression, in which regression coefficients are themselves defined by nested regressions (unlike in R). We explain how our calculus captures the essence of the formula DSL found in R. We describe the design and implementation of Fabular, a version of the Tabular schema-driven probabilistic programming language, enriched with formulas based on our regression calculus. To the best of our knowledge, this is the first formal description of the core ideas of R's formula notation, the first development of a calculus of regression formulas, and the first demonstration of the benefits of composing regression formulas and latent variables in a probabilistic programming language.
</font></blockquote>
<blockquote><font size="-1">
Keywords: Bayesian inference, hierarchical models, linear regression, probabilistic programming, relational data
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="ml16typeclasses">2</a>]
</td>
<td>
Claudio Russo, Matthew Windsor, Don Syme, Rupert Horlick, and James Clarke.
  Classes for the masses.
  In <em>2016: ACM-SIGPLAN Workshop on ML (Informal Proceedings)</em>,
  POPL '16, New York, NY, USA, 2016. ACM.<br />
[ <a href="http://www.mlworkshop.org/2016-7.pdf">.pdf</a> ]
<blockquote><font size="-1">

Type classes are an immensely popular and productive feature of Haskell. They have since been adopted in, and adapted to, numerous other languages, including theorem provers. This talk will show that type classes have a natural and efficient representation in .NET. This paves the way for the extension of F# and other .NET languages with Haskell style type classes. The representation is type preserving and promises easy and safe cross-language inter-operation. We are currently, and rapidly, extending the open source C# compiler and language service, Roslyn, with support for type classes but intend to do the same for F# once that work has been completed.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="esop15tabular">3</a>]
</td>
<td>
Andrew&nbsp;D. Gordon, Claudio Russo, Marcin Szymczak, Johannes Borgstroem, Nicolas
  Rolland, Thore Graepel, and Daniel Tarlow.
  Probabilistic programs as spreadsheet queries.
  In Jan Vitek, editor, <em>Programming Languages and Systems</em>, volume
  9032 of <em>Lecture Notes in Computer Science</em>, pages 1-25. Springer Berlin
  Heidelberg, 2015.<br />
[ <a href="http://dx.doi.org/10.1007/978-3-662-46669-8_1">http</a> ]
<blockquote><font size="-1">
We describe the design, semantics, and implementation of a probabilistic programming language where programs are spreadsheet queries. Given an input database consisting of tables held in a spreadsheet, a query constructs a probabilistic model conditioned by the spreadsheet data, and returns an output database determined by inference. This work extends probabilistic programming systems in three novel aspects: (1) embedding in spreadsheets, (2) dependently typed functions, and (3) typed distinction between random and query variables. It empowers users with knowledge of statistical modelling to do inference simply by editing textual annotations within their spreadsheets, with no other coding.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="popl14tabular">4</a>]
</td>
<td>
Andrew&nbsp;D. Gordon, Thore Graepel, Nicolas Rolland, Claudio Russo, Johannes
  Borgstrom, and John Guiver.
  Tabular: A schema-driven probabilistic programming language.
  In <em>Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on
  Principles of Programming Languages</em>, POPL '14, pages 321-334, New York, NY,
  USA, 2014. ACM.<br />
[ <a href="http://doi.acm.org/10.1145/2535838.2535850">http</a> ]
<blockquote><font size="-1">
We propose a new kind of probabilistic programming language for machine learning. We write programs simply by annotating existing relational schemas with probabilistic model expressions. We describe a detailed design of our language, Tabular, complete with formal semantics and type system. A rich series of examples illustrates the expressiveness of Tabular. We report an implementation, and show evidence of the succinctness of our notation relative to current best practice. Finally, we describe and verify a transformation of Tabular schemas so as to predict missing values in a concrete database. The ability to query for missing values provides a uniform interface to a wide variety of tasks, including classification, clustering, recommendation, and ranking.

</font></blockquote>
<blockquote><font size="-1">
Keywords: bayesian reasoning, machine learning, model-learner pattern, probabilistic programming, relational data
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="JFPfing">5</a>]
</td>
<td>
Andreas Rossberg, Claudio Russo, and Derek Dreyer.
  F-ing modules.
  <em>Journal of Functional Programming</em>, 24:529-607, 2014.<br />
[ <a href="http://journals.cambridge.org/article_S0956796814000264">http</a> ]
<blockquote><font size="-1">
ML modules are a powerful language mechanism for decomposing programs into reusable components. Unfortunately, they also have a reputation for being ‚Äúcomplex‚Äù and requiring fancy type theory that is mostly opaque to non-experts. While this reputation is certainly understandable, given the many non-standard methodologies that have been developed in the process of studying modules, we aim here to demonstrate that it is undeserved. To do so, we present a novel formalization of ML modules, which defines their semantics directly by a compositional ‚Äúelaboration‚Äù translation into plain System F_&omega; (the higher-order polymorphic Œª-calculus). To demonstrate the scalability of our ‚ÄúF-ing‚Äù semantics, we use it to define a representative, higher-order ML-style module language, encompassing all the major features of existing ML module dialects (except for recursive modules). We thereby show that ML modules are merely a particular mode of use of System F_&omega;.<p>
To streamline the exposition, we present the semantics of our module language in stages. We begin by defining a subset of the language supporting a Standard ML-like language with second-class modules and generative functors. We then extend this sublanguage with the ability to package modules as first-class values (a very simple extension, as it turns out) and OCaml-style applicative functors (somewhat harder). Unlike previous work combining both generative and applicative functors, we do not require two distinct forms of functor or signature sealing. Instead, whether a functor is applicative or not depends only on the computational purity of its body. In fact, we argue that applicative/generative is rather incidental terminology for pure versus impure functors. This approach results in a semantics that we feel is simpler and more natural than previous accounts, and moreover prohibits breaches of abstraction safety that were possible under them.

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="tacas13">6</a>]
</td>
<td>
Sooraj Bhat, Johannes Borgstrˆm, Andrew&nbsp;D. Gordon, and Claudio Russo.
  Deriving probability density functions from probabilistic functional
  programs.
  In <em>Proceedings of the 19th international conference on Tools and
  Algorithms for the Construction and Analysis of Systems</em>, TACAS'13, pages
  508-522, Berlin, Heidelberg, 2013. Springer-Verlag.<br />
[ <a href="http://dx.doi.org/10.1007/978-3-642-36742-7_35">http</a> ]
<blockquote><font size="-1">

A Bayesian model is based on a pair of probability distributions, known as the prior and sampling distributions. A wide range of fundamental machine learning tasks, including regression, classification, clustering, and many others, can all be seen as Bayesian models. We propose a new probabilistic programming abstraction, a typed Bayesian model, which is based on a pair of probabilistic expressions for the prior and sampling distributions. A sampler for a model is an algorithm to compute synthetic data from its sampling distribution, while a learner for a model is an algorithm for probabilistic inference on the model. Models, samplers, and learners form a generic programming pattern for model-based inference. They support the uniform expression of common tasks including model testing, and generic compositions such as mixture models, evidence-based model averaging, and mixtures of experts. A formal semantics supports reasoning about model equivalence and implementation correctness. By developing a series of examples and three learner implementations based on exact inference, factor graphs, and Markov chain Monte Carlo, we demonstrate the broad applicability of this new programming pattern.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="popl13learner">7</a>]
</td>
<td>
Andrew&nbsp;D. Gordon, Mihhail Aizatulin, Johannes Borgstrom, Guillaume Claret,
  Thore Graepel, Aditya&nbsp;V. Nori, Sriram&nbsp;K. Rajamani, and Claudio Russo.
  A model-learner pattern for bayesian reasoning.
  In <em>Proceedings of the 40th annual ACM SIGPLAN-SIGACT symposium
  on Principles of programming languages</em>, POPL '13, pages 403-416, New York,
  NY, USA, 2013. ACM.<br />
[ <a href="http://doi.acm.org/10.1145/2429069.2429119">http</a> ]
<blockquote><font size="-1">

A Bayesian model is based on a pair of probability distributions, known as the prior and sampling distributions. A wide range of fundamental machine learning tasks, including regression, classification, clustering, and many others, can all be seen as Bayesian models. We propose a new probabilistic programming abstraction, a typed Bayesian model, which is based on a pair of probabilistic expressions for the prior and sampling distributions. A sampler for a model is an algorithm to compute synthetic data from its sampling distribution, while a learner for a model is an algorithm for probabilistic inference on the model. Models, samplers, and learners form a generic programming pattern for model-based inference. They support the uniform expression of common tasks including model testing, and generic compositions such as mixture models, evidence-based model averaging, and mixtures of experts. A formal semantics supports reasoning about model equivalence and implementation correctness. By developing a series of examples and three learner implementations based on exact inference, factor graphs, and Markov chain Monte Carlo, we demonstrate the broad applicability of this new programming pattern.

</font></blockquote>
<blockquote><font size="-1">
Keywords: bayesian reasoning, machine learning, model-learner pattern, probabilistic programming
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="asynccsharp">8</a>]
</td>
<td>
Gavin Bierman, Claudio Russo, Geoffrey Mainland, Erik Meijer, and Mads
  Torgersen.
  Pause 'n' play: Formalizing asynchronous C#.
  In James Noble, editor, <em>ECOOP 2012 - Object-Oriented
  Programming</em>, Lecture Notes in Computer Science. Springer Berlin /
  Heidelberg, June 2012.<br />
[ <a href="http://dx.doi.org/10.1007/978-3-642-31057-7_12">http</a> ]
<blockquote><font size="-1">
Writing applications that connect to external services and yet remain responsive and resource conscious is a difficult task. With the rise of web programming this has become a common problem. The solution lies in using asynchronous operations that separate issuing a request from waiting for its completion. However, doing so in common object-oriented languages is difficult and error prone. Asynchronous operations rely on callbacks, forcing the programmer to cede control. This inversion of control-flow impedes the use of structured control constructs, the staple of sequential code. In this paper, we describe the language support for asynchronous programming in the upcoming version of C#. The feature enables asynchronous programming using structured control constructs. Our main contribution is a precise mathematical description that is abstract (avoiding descriptions of compiler-generated state machines) and yet sufficiently concrete to allow important implementation properties to be identified and proved correct.

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="padl2012">9</a>]
</td>
<td>
Claudio Russo and Neng&nbsp;Fa Zhou, editors.
  <em>Fourteenth International Symposium on Practical Aspects of
  Declarative Languages (PADL 2007)</em>, volume 7149 of <em>Lecture Notes In
  Computer Science (LNCS)</em>. Springer-Verlag, January 2012.<br />

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="oopsla11-scalable-join-patterns">10</a>]
</td>
<td>
Aaron&nbsp;J. Turon and Claudio&nbsp;V. Russo.
  Scalable Join Patterns.
  In <em>Proceedings of the 2011 ACM International Conference on
  Object Oriented Programming Systems Languages and Applications</em>, OOPSLA '11,
  pages 575-594, New York, NY, USA, 2011. ACM.<br />
[ <a href="./papers/scalablejoins.pdf">.pdf</a> ]
<blockquote><font size="-1">

Coordination can destroy scalability in parallel programming.  A
comprehensive library of scalable synchronization primitives is
therefore an essential tool for exploiting parallelism.
Unfortunately, such primitives do not easily combine to yield
solutions to more complex problems.  We demonstrate that a concurrency
library based on Fournet and Gonthier's join calculus can provide
declarative and scalable coordination.  By declarative, we mean
that the programmer needs only to write down the constraints of a
coordination problem, and the library will automatically derive a
correct solution.  By scalable, we mean that the derived
solutions deliver robust performance both as the number of processors
increases, and as the complexity of the coordination problem grows.
We validate our claims empirically on seven coordination problems,
comparing our generic solution to specialized algorithms from the
literature.

</font></blockquote>
<blockquote><font size="-1">
Keywords: concurrency, message passing, parallelism
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="fingtldi">11</a>]
</td>
<td>
Andreas Rossberg, Claudio&nbsp;V. Russo, and Derek Dreyer.
  F-ing Modules.
  In <em>2010 ACM SIGPLAN Workshop on Types in Language Design and
  Implementation (TLDI2010)</em>, 2010.
  Coq formalization
  <a href="http://www.mpi-sws.org/~rossberg/f-ing/f-ing.zip">http://www.mpi-sws.org/~rossberg/f-ing/f-ing.zip</a>.<br />
[ <a href="http://research.microsoft.com/~crusso/papers/fingmodules.pdf">.pdf</a> ]
<blockquote><font size="-1">

 ML modules are a powerful language mechanism for decomposing programs
into reusable components.  Unfortunately, they also have a reputation
for being <tt>complex</tt> and requiring fancy type theory that is mostly
opaque to non-experts.  While this reputation is certainly
understandable, given the many non-standard methodologies that have
been developed in the process of studying modules, we aim here to
demonstrate that it is undeserved.  To do so, we give a very simple
elaboration semantics for a full-featured, higher-order ML-like module
language.  Our elaboration defines the meaning of module expressions
by a straightforward, compositional translation into vanilla System
F-omega (the higher-order polymorphic lambda-calculus), under plain
F-omega typing environments.  We thereby show that ML modules are
merely a particular mode of use of System F-omega.<p>
Our module language supports the usual second-class modules with
Standard ML-style generative functors and local module definitions.
To demonstrate the versatility of our approach, we further extend the
language with the ability to package modules as first-class values-a
very simple extension, as it turns out.  Our approach also scales to
handle OCaml-style applicative functor semantics, but the details are
significantly more subtle, so we leave their presentation to a future,
expanded version of this paper.<p>
Lastly, we report on our experience using the <tt>locally nameless</tt>
approach in order to mechanize the soundness of our elaboration
semantics in Coq.

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="icfp09-parallel-cml">12</a>]
</td>
<td>
John Reppy, Claudio Russo, and Yingqi Xiao.
  Parallel Concurrent ML.
  In <em>Proceedings of the 14th ACM SIGPLAN International Conference
  on Functional Programming (ICFP 2009)</em>, September 2009.<br />
[ <a href="http://research.microsoft.com/~crusso/papers/icfp-parallel-cml.pdf">.pdf</a> ]
<blockquote><font size="-1">

    Concurrent ML (CML) is a high-level message-passing language that supports
    the construction of first-class synchronous abstractions called
    events.  This mechanism has proven quite effective over the years and
    has been incorporated in a number of other languages.  While CML
    provides a concurrent programming model, its implementation has always
    been limited to uniprocessors.  This limitation is exploited in the
    implementation of the synchronization protocol that underlies the event
    mechanism, but with the advent of cheap parallel processing on the
    desktop (and laptop), it is time for Parallel CML.
    
    Parallel implementations of CML-like primitives for
    Java and Haskell exist, but build on high-level synchronization
    constructs that are unlikely to perform well.  This paper presents a
    novel, parallel implementation of CML that exploits a purpose-built
    optimistic concurrency protocol designed for both correctness and
    performance on shared-memory multiprocessors.
    This work extends and
    completes an earlier protocol that supported just a strict subset of
    CML with synchronization on input, but not output events.  Our main
    contributions are a model-checked reference implementation of the
    protocol and two concrete implementations.  This paper focuses on
    Manticore's functional, continuation-based implementation but briefly
    discusses an independent, thread-based implementation written in C#
    and running on Microsoft's stock, parallel runtime. Although very
    different in detail, both derive from the same design. Experimental
    evaluation of the Manticore implementation reveals good
    performance, despite the extra overhead of multiprocessor synchronization.
  
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="ml09-qml">13</a>]
</td>
<td>
Claudio&nbsp;V. Russo and Dimitrios Vytiniotis.
  QML: Explicit First-Class Polymorphism for ML.
  In <em>2009: ACM-SIGPLAN Workshop on ML</em>. ACM Press, August 2009.
  (downloads <a href="http://research.microsoft.com/~crusso/qml">http://research.microsoft.com/~crusso/qml</a>).<br />
[ <a href="http://research.microsoft.com/~crusso/papers/qml.pdf">.pdf</a> ]
<blockquote><font size="-1">
 
Recent years have seen a revival of interest in
extending ML's predicative type inference system with impredicative
quantification in the style of System F, for which type inference is
undecidable.  This paper suggests a modest extension of ML with System
F types: the heart of the idea is to extend the language of types with
unary universal and existential quantifiers.  The introduction and
elimination of a quantified type is never inferred but indicated <em>
explicitly</em> by the programmer by supplying the quantified type
itself. Quantified types co-exist with ordinary ML schemes, which are
in turn <em>implicitly</em> introduced and eliminated at
<tt>let</tt>-bindings and use sites, respectively.  The resulting
language, QML, does not impose any restriction on instantiating
quantified variables with quantified types; neither <tt>let</tt>- nor
&lambda;-bound variables ever require a type annotation, even if the
variable's inferred scheme or type involves quantified types.  This
proposal, albeit more verbose in terms of annotations than others, is
simple to specify, implement, understand, and formalize.  

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="oopsla08cb">14</a>]
</td>
<td>
Claudio Russo.
  Join Patterns for Visual Basic.
  In <em>OOPSLA 2008: Proceedings of the 2008 ACM Conference on
  Object-Oriented Programming, Systems, Languages and Applications</em>. ACM Press,
  October 2008.<br />
[ <a href="http://research.microsoft.com/~crusso/papers/cb.pdf">.pdf</a> ]
<blockquote><font size="-1">

We describe an extension of Visual Basic 9.0 with asynchronous
concurrency constructs - join patterns - based on the join calculus.
Our design of Concurrent Basic (CB) builds on earlier work on
Polyphonic C# and Comega.  Since that work, the need for
language-integrated concurrency has only grown, both due to the
arrival of commodity, multi-core hardware, and the trend for Rich
Internet Applications that rely on asynchronous client-server
communication to hide latency.  Unlike its predecessors, CB adopts an
event-like syntax that should be familiar to existing VB programmers.
Coupled with Generics, CB allows one to declare re-useable concurrency
abstractions that were clumsy to express previously.  CB removes its
ancestors' inconvenient inheritance restriction, while providing new
extensibility points useful in practical applications that must
co-exist with or want to exploit alternative threading models
available on the platform.  CB is implemented as an extension of the
production VB 9.0 compiler.

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo07JoinsLibrary">15</a>]
</td>
<td>
Claudio Russo.
  The Joins Concurrency Library.
  In Michael Hanus, editor, <em>Ninth International Symposium on
  Practical Aspects of Declarative Languages (PADL 2007)</em>, volume 4354 of <em>
  Lecture Notes In Computer Science (LNCS)</em>, pages 260-274. Springer-Verlag,
  January 2007.
  (c)&nbsp;Springer-Verlag,
  <a href="http://www.springer.de/comp/lncs/index.html">http://www.springer.de/comp/lncs/index.html</a>.<br />
[ <a href="http://research.microsoft.com/~crusso/papers/padl07.pdf">.pdf</a> ]
<blockquote><font size="-1">

Comega extended C# 1.x with a
simple, declarative and powerful model of concurrency - join patterns
- applicable both to multithreaded applications and to the
orchestration of asynchronous, event-based distributed
applications. With Generics available in C# 2.0, we can now
provide join patterns as a library rather than a language
feature. The Joins library extends its clients with an
embedded, type-safe and mostly declarative language for expressing
synchronization patterns.  The library has some advantages over Comega: it
is language neutral, supporting other languages like Visual Basic; its join
patterns are more dynamic, allowing solutions difficult to express with 
Comega; its code is easy to modify,
fostering experimentation. Although presenting fewer optimization
opportunities, the implementation is efficient and its
interface makes it trivial to translate Comega programs to C#.  We describe the interface and implementation of Joins which
(ab)uses almost every feature of Generics. 
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="mlworkshop07">16</a>]
</td>
<td>
Derek Dreyer and Claudio Russo, editors.
  <em>ML '07: Proceedings of the 2007 ACM SIGPLAN Workshop on ML</em>,
  New York, NY, USA, 2007. ACM.
  565075.<br />

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="CSharpVarianceConstraints">17</a>]
</td>
<td>
Burak Emir, Andrew&nbsp;J. Kennedy, Claudio Russo, and Dachuan Yu.
  Variance and generalized constraints for C# generics.
  In <em>European Conference on Object-Oriented Programming (ECOOP)</em>,
  July 2006.<br />
[ <a href="http://research.microsoft.com/~akenn/generics/ECOOP06.pdf">.pdf</a> ]
<blockquote><font size="-1">
Generic types in C# behave invariantly with respect to
subtyping. We propose a system of type-safe variance for
C# that supports the declaration of covariant and contravariant
type parameters on generic types. To support more
widespread application of variance we also generalize the existing
constraint mechanism with arbitrary subtype assertions on
classes and methods. This extension is useful even in the absence of
variance, and subsumes equational constraints proposed
for Generalized Algebraic Data Types (GADTs).
We formalize the subtype relation in both declarative and
syntax-directed style, and describe and prove the correctness of
algorithms for constraint closure and subtyping. Finally, we formalize
and prove a type safety theorem for a featherweight language with
variant classes and generalized constraints.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="oopsla05GADTsinOOP">18</a>]
</td>
<td>
Andrew Kennedy and Claudio Russo.
  Generalized algebraic data types and object-oriented programming.
  In <em>OOPSLA 2005: Proceedings of the 2005 ACM Conference on
  Object-Oriented Programming, Systems, Languages and Applications</em>. ACM Press,
  October 2005.<br />
[ <a href="http://research.microsoft.com/~akenn/generics/gadtoop.pdf">.pdf</a> ]
<blockquote><font size="-1">
Generalized algebraic data types (GADTs) have received much attention
recently in the functional programming community. They generalize the
type-parameterized datatypes of ML and Haskell by permitting
constructors to produce different type-instantiations of the same
datatype. GADTs have a number of applications, including
strongly-typed evaluators, generic pretty-printing, generic traversals
and queries, and typed LR parsing.  We show that existing
object-oriented programming languages such as Java and C# can
express GADT definitions, and a large class of GADT-manipulating
programs, through the use of generics, subclassing, and virtual
dispatch. However, some programs can be written only through the use of
redundant run-time casts.  We propose a generalization of the type constraint
mechanisms of C# and Java to avoid the need for such casts,
present a Visitor pattern for GADTs, and describe a <tt>switch</tt>
construct as an alternative to virtual dispatch on datatypes. We
formalize both extensions and prove a type soundness result.

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo05shrinking">19</a>]
</td>
<td>
Andrew Kennedy, Nick Benton, Sam Lindley, and Claudio Russo.
  Shrinking reductions in SML.NET.
  In <em>16th International Workshop on Implementation and Application
  of Functional Languages (IFL '04).</em>, volume&nbsp;41 of <em>Springer Lecture Notes
  in Computer Science</em>. Springer Verlag, September 2004.<br />
[ <a href="./papers/ifl04.pdf">.pdf</a> ]
<blockquote><font size="-1">
One performance-critical phase in the SML.NET compiler involves
rewriting intermediate terms to monadic normal form and performing
non-duplicating beta-reductions. We present an imperative algorithm
for this simplification phase, working with a mutable, pointer-based
term representation, which significantly outperforms our existing
functional algorithm.
This is the first implementation and evaluation of a linear-time rewriting algorithm
proposed by Appel and Jim.

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo04smlnetexp">20</a>]
</td>
<td>
Nick Benton, Andrew Kennedy, and Claudio&nbsp;V. Russo.
  Adventures in interoperability: the SML.NET experience.
  In <em>PPDP '04: Proceedings of the 6th ACM SIGPLAN International
  Conference on Principles and Practice of Declarative Programming</em>, pages
  215-226. ACM Press, August 2004.<br />
[ <a href="./papers/ppdp04.pdf">.pdf</a> ]
<blockquote><font size="-1">
SML.NET is a compiler for Standard ML that targets the Common Language Runtime and is integrated into the Visual Studio development environment. It supports easy interoperability with other .NET languages via a number of language extensions, which go considerably beyond those of our earlier compiler, MLj.This paper describes the new language extensions and the features of the Visual Studio plugin, including syntax highlighting, Intellisense, continuous type inference and debugger support. We discuss our experiences using SML.NET to write SML programs that interoperate with other .NET languages, libraries and frameworks. Examples include the Visual Studio plugin itself (written in SML.NET, using .NET's COM interop features to integrate in a C++ application) and writing ASP.NET and Pocket PC applications in SML. 

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo2003monograph">21</a>]
</td>
<td>
Claudio&nbsp;V. Russo.
  Types for Modules.
  <em>Electronic Notes in Theoretical Computer Science</em>, 60, January
  2003.
  This monograph contains an additional chapter not included in the
  thesis version.<br />
[ <a href="./papers/entcs.pdf">.pdf</a> ]
<blockquote><font size="-1">

The programming language Standard ML is an amalgam of two, largely 
orthogonal, languages.  The Core language expresses details of algorithms 
and data structures.  The Modules language expresses the modular 
architecture of a software system.  Both languages are statically typed, 
with their static and dynamic semantics specified by a formal definition.<p>
Over the past decade, Standard ML Modules has been the source of 
inspiration for much research into the type-theoretic foundations of 
modules languages.  Despite these efforts, a proper type-theoretic 
understanding of its static semantics
has remained elusive.  In this thesis, we use Type 
Theory as a guideline to reformulate the unconventional
static semantics of Modules, providing a 
basis for useful extensions to the Modules language.<p>
Our starting point is a stylised presentation of the existing static 
semantics of Modules, parameterised by an arbitrary Core language.  We 
claim that the type-theoretic concepts underlying Modules are type 
parameterisation, type quantification and subtyping.  We substantiate this 
claim by giving a provably equivalent semantics with an alternative, more 
type-theoretic presentation.  In particular, we show that the notion of 
type generativity corresponds to existential quantification over types.  In 
contrast to previous accounts, our analysis does not involve first-order 
dependent types.<p>
Our first extension generalises Modules to higher-order, allowing modules 
to take parameterised modules as arguments, and return them as results.  We 
go beyond previous proposals for higher-order Modules
by supporting a notion of type generativity.  
We give a sound and complete algorithm for type-checking higher-order 
Modules.  Our second extension permits modules to be treated as first-class 
citizens of an ML-like Core language, greatly extending the range of 
computations on modules.  Each extension arises from a natural 
generalisation of our type-theoretic semantics.<p>
This thesis also addresses two pragmatic concerns.  First, we propose 
a simple approach to the separate compilation of Modules, which is 
adequate in practice but has theoretical limitations.  We suggest a 
modified syntax and semantics that alleviates these limitations.  Second, we 
study the type inference problem posed by uniting our extensions to 
higher-order and first-class modules with an implicitly-typed, ML-like 
Core language.  We present a hybrid type inference algorithm 
that integrates the classical algorithm for ML with the type-checking 
algorithm for Modules.

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo01recursive">22</a>]
</td>
<td>
Claudio&nbsp;V. Russo.
  Recursive Structures for Standard ML.
  In <em>Proceedings of the 2001 ACM SIGPLAN International Conference
  on Functional Programming</em>, pages 50-61. ACM Press, September 2001.<br />
[ <a href="./papers/icfp01.pdf">.pdf</a> ]
<blockquote><font size="-1">
Standard ML is a statically typed programming language that is suited for the construction of both small and large programs. <tt>Programming in the small</tt> is captured by Standard ML's Core language. <tt>Programming in the large</tt> is captured by Standard ML's Modules language that provides constructs for organizing related Core language definitions into self-contained modules with descriptive interfaces. While the Core is used to express details of algorithms and data structures, Modules is used to express the overall architecture of a software system. In Standard ML, modular programs must have a strictly hierarchical structure: the dependency between modules can never be cyclic. In particular, definitions of mutually recursive Core types and values, that arise frequently in practice, can never span module boundaries. This limitation compromises modular programming, forcing the programmer to merge conceptually (i.e. architecturally) distinct modules. We propose a practical and simple extension of the Modules language that caters for cyclic dependencies between both types and terms defined in separate modules. Our design leverages existing features of the language, supports separate compilation of mutually recursive modules and is easy to implement. 
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo00lily">23</a>]
</td>
<td>
Gavin&nbsp;M. Bierman, Andrew&nbsp;M. Pitts, and Claudio&nbsp;V. Russo.
  Operational properties of Lily, a polymorphic linear lambda
  calculus with recursion.
  In <em>Fourth International Workshop on Higher Order Operational
  Techniques in Semantics, MontrÈal</em>, volume&nbsp;41 of <em>Electronic Notes in
  Theoretical Computer Science</em>. Elsevier, September 2000.<br />
[ <a href="./papers/hoots00.pdf">.pdf</a> ]
<blockquote><font size="-1">
Plotkin has advocated the combination of linear lambda calculus, polymorphism and fixed point recursion as an expressive semantic metalanguage. We study its expressive power from an operational point of view. We show that the naturally call-by-value operators of linear lambda calculus can be given a call-by-name semantics without affecting termination at exponential types and hence without affecting ground contextual equivalence. This result is used to prove properties of a logical relation that provides a new extensional characterisation of ground contextual equivalence and relational parametricity properties of polymorphic types. 
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo00firstclass">24</a>]
</td>
<td>
Claudio&nbsp;V. Russo.
  First-class Structures for Standard ML.
  In <em>Programming Languages and Systems, ESOP 2000</em>, volume 1782,
  pages 336-350. Springer Verlag, March 2000.<br />
[ <a href="./papers/fcstr.pdf">.pdf</a> ]
<blockquote><font size="-1">
Standard ML is a statically typed programming language that is suited for the construction of both small and large programs. Programming in the small is captured by Standard ML's Core language. Programming in the large is captured by Standard ML's Modules language that provides constructs for organising related Core language definitions into self-contained modules with descriptive interfaces. While the Core is used to express details of algorithms and data structures, Modules is used to express the overall architecture of a software system. The Modules and Core languages are stratified in the sense that modules may not be manipulated as ordinary values of the Core. This is a limitation, since it means that the architecture of a program cannot be reconfigured according to run-time demands. We propose a novel extension of the language that allows modules to be manipulated as first-class values of the Core language. The extension greatly extends the expressive power of the language and has been shown to be compatible with both Core type inference and a separate extension to higher-order modules.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo00firstclassjournal">25</a>]
</td>
<td>
Claudio&nbsp;V. Russo.
  First-class Structures for Standard ML.
  <em>Nordic Journal Of Computing</em>, 7:348-374, January 2000.
  Copy available on request.<br />
[ <a href="http://www.cs.helsinki.fi/njc/">http</a> ]
<blockquote><font size="-1">
Standard ML is a statically typed programming language that is suited for the construction of both small and large programs. ``Programming in the small'' is captured by Standard ML's Core language. ``Programming in the large'' is captured by Standard ML's Modules language that provides constructs for organising related Core language definitions into self-contained modules with descriptive interfaces. While the Core is used to express details of algorithms and data structures, Modules is used to express the overall architecture of a software system. The Modules and Core languages are stratified in the sense that modules may not be manipulated as ordinary values of the Core. This is a limitation, since it means that the architecture of a program cannot be reconfigured according to run-time demands. We propose a novel and practical extension of the language that allows modules to be manipulated as first-class values of the Core language. 
    
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo99nondep">26</a>]
</td>
<td>
Claudio&nbsp;V. Russo.
  Non-dependent types for Standard ML Modules.
  In <em>PPDP '99: Proceedings of the International Conference PPDP'99
  on Principles and Practice of Declarative Programming</em>, pages 80-97.
  Springer-Verlag, September 1999.<br />
[ <a href="./papers/ppdp99.pdf">.pdf</a> ]
<blockquote><font size="-1">
Two of the distinguishing features of Standard ML Modules are its term dependent type syntax and the use of type generativity in its static semantics. From a type-theoretic perspective, the former suggests that the language involves first-order dependent types, while the latter has been regarded as an extra-logical device that bears no direct relation to type-theoretic constructs. We reformulate the existing semantics of Modules to reveal a purely second-order type theory. In particular, we show that generativity corresponds precisely to existential quantification over types and that the remainder of the Modules type structure is based exclusively on the second-order notions of type parameterisation, universal type quantification and subtyping. Our account is more direct than others and has been shown to scale naturally to both higher-order and first-class modules. 

</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right">
[<a name="russo98thesis">27</a>]
</td>
<td>
Claudio&nbsp;V. Russo.
  <em>Types for Modules</em>.
  PhD thesis, Edinburgh University, Edinburgh, Scotland, March 1998.
  LFCS Thesis ECS-LFCS-98-389. [<a href="#russo2003monograph">21</a>] is a
  version of this document with an additional chapter on Moscow ML, proper
  bookmarks, and hyper links.<br />
[ <a href="./papers/thesis.pdf">.pdf</a> ]
<blockquote><font size="-1">
The programming language Standard ML is an amalgam of two, largely orthogonal, languages. The Core language expresses details of algorithms and data structures. The Modules language expresses the modular architecture of a software system. Both languages are statically typed, with their static and dynamic semantics specified by a formal definition.<p>
Over the past decade, Standard ML Modules has been the source of inspiration for much research into the type-theoretic foundations of modules languages. Despite these efforts, a proper type-theoretic understanding of its static semantics has remained elusive. In this thesis, we use Type Theory as a guideline to reformulate the unconventional static semantics of Modules, providing a basis for useful extensions to the Modules language.<p>
Our starting point is a stylised presentation of the existing static semantics of Modules, parameterised by an arbitrary Core language. We claim that the type-theoretic concepts underlying Modules are type parameterisation, type quantification and subtyping. We substantiate this claim by giving a provably equivalent semantics with an alternative, more type-theoretic presentation. In particular, we show that the notion of type generativity corresponds to existential quantification over types. In contrast to previous accounts, our analysis does not involve first-order dependent types.<p>
Our first extension generalises Modules to higher-order, allowing modules to take parameterised modules as arguments, and return them as results. We go beyond previous proposals for higher-order Modules by supporting a notion of type generativity. We give a sound and complete algorithm for type-checking higher-order Modules. Our second extension permits modules to be treated as first-class citizens of an ML-like Core language, greatly extending the range of computations on modules. Each extension arises from a natural generalisation of our type-theoretic semantics.<p>
This thesis also addresses two pragmatic concerns. First, we propose a simple approach to the separate compilation of Modules, which is adequate in practice but has theoretical limitations. We suggest a modified syntax and semantics that alleviates these limitations. Second, we study the type inference problem posed by uniting our extensions to higher-order and first-class modules with an implicitly-typed, ML-like Core language. We present a hybrid type inference algorithm that integrates the classical algorithm for ML with the type-checking algorithm for Modules.

</font></blockquote>

</td>
</tr>
</table><hr><p><em>This file has been generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.74</em></p>
</body>
</html>
